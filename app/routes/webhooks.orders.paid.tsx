import type { ActionFunctionArgs } from "@remix-run/node";
import { authenticate } from "../shopify.server";
import db from "../db.server";
import { EmailService } from "../lib/email.server";

export const action = async ({ request }: ActionFunctionArgs) => {
  const { shop, payload, topic, admin } = await authenticate.webhook(request);

  console.log(`Received ${topic} webhook for ${shop}`);

  try {
    const order = payload as any;
    
    // Buscar configura√ß√µes da loja
    const settings = await db.reviewSettings.findUnique({
      where: { shop },
    });

    // MUDAN√áA: Usar autoSendEnabled para envio autom√°tico (webhook)
    if (!settings || !settings.autoSendEnabled) {
      console.log("Automatic sending disabled for shop:", shop);
      return new Response();
    }

    // Verificar se temos as configura√ß√µes de email necess√°rias baseado no provedor
    let emailConfigValid = false;

    if (settings.emailProvider === "mailtrap") {
      // Para Mailtrap, precisamos do token e inbox ID
      emailConfigValid = !!(settings.mailtrapToken && settings.mailtrapInboxId && settings.emailFromAddress);
    } else {
      // Para outros provedores (SendGrid, Mailgun), precisamos da API Key
      emailConfigValid = !!(settings.emailApiKey && settings.emailFromAddress);
    }

    if (!emailConfigValid) {
      console.log(`Email configuration incomplete for shop: ${shop}. Provider: ${settings.emailProvider}`);
      return new Response();
    }

    const customerId = order.customer?.id ? order.customer.id.toString() : null;
    
    // Tentar extrair email de diferentes locais poss√≠veis
    let customerEmail = order.customer?.email || 
                       order.email ||
                       order.contact_email ||
                       order.billing_address?.email ||
                       order.shipping_address?.email;

    // Se n√£o encontrou email e temos um customer ID, buscar via API REST
    if (!customerEmail && customerId && admin) {
      try {
        console.log("üîç Tentando buscar email do cliente...");
        console.log("‚ö†Ô∏è Email n√£o encontrado no payload do webhook para customer ID:", customerId);
        
        // Solu√ß√£o alternativa: usar email tempor√°rio baseado no customer ID
        // O cliente poder√° confirmar o email real quando acessar o link de review
        customerEmail = `customer-${customerId}@temp.${shop}`;
        console.log("üí° Usando email tempor√°rio:", customerEmail);
        
      } catch (error) {
        console.error("‚ùå Erro ao processar cliente:", error);
      }
    }

    const customerName = order.customer ? 
      `${order.customer.first_name || ''} ${order.customer.last_name || ''}`.trim() : 
      order.billing_address?.name || 
      order.shipping_address?.name ||
      order.billing_address?.first_name && order.billing_address?.last_name ? 
        `${order.billing_address.first_name} ${order.billing_address.last_name}`.trim() :
      order.shipping_address?.first_name && order.shipping_address?.last_name ?
        `${order.shipping_address.first_name} ${order.shipping_address.last_name}`.trim() :
      'Cliente';

    // Debug: Log da estrutura do pedido
    console.log("üîç Order debug info:", {
      orderId: order.id,
      hasCustomer: !!order.customer,
      customerId: customerId,
      customerEmail: order.customer?.email,
      orderEmail: order.email,
      contactEmail: order.contact_email,
      billingEmail: order.billing_address?.email,
      shippingEmail: order.shipping_address?.email,
      finalEmail: customerEmail,
    });

    if (!customerEmail) {
      console.log("‚ùå No customer email found for order:", order.id);
      console.log("Order payload keys:", Object.keys(order));
      console.log("Customer object:", order.customer);
      console.log("Billing address:", order.billing_address);
      console.log("Shipping address:", order.shipping_address);
      return new Response();
    }

    // Calcular data de envio usando autoSendDaysAfter
    const orderDate = new Date(order.created_at);
    const sendDate = new Date(orderDate);
    const daysAfter = settings.autoSendDaysAfter || 3;
    sendDate.setDate(sendDate.getDate() + daysAfter);

    console.log(`üìÖ Agendando envios autom√°ticos para ${sendDate.toISOString()} (${daysAfter} dias ap√≥s pedido)`);

    let convitesCriados = 0;

    // Processar produtos do pedido
    for (const lineItem of order.line_items || []) {
      const productId = `gid://shopify/Product/${lineItem.product_id}`;
      
      // Verificar se o cliente j√° fez review para este produto
      if (customerId || customerEmail) {
        const existingReview = await db.review.findFirst({
          where: {
            shop,
            productId,
            OR: [
              { customerId },
              { customerEmail },
            ],
          },
        });

        if (existingReview) {
          console.log(`Customer already reviewed product ${productId}`);
          continue;
        }
      }

      // Verificar se j√° existe um convite pendente
      const existingInvitation = await db.reviewInvitation.findFirst({
        where: {
          shop,
          customerEmail,
          productId,
          responded: false,
        },
      });

      if (existingInvitation) {
        console.log(`Review invitation already exists for ${customerEmail} - ${lineItem.title}`);
        continue;
      }

      // Buscar dados do produto via GraphQL
      let productTitle = lineItem.title || 'Produto';
      let productImage = null;

      try {
        if (admin) {
          const productQuery = `
            query getProduct($id: ID!) {
              product(id: $id) {
                title
                featuredImage {
                  url
                }
              }
            }
          `;

          const productResponse = await admin.graphql(productQuery, {
            variables: { id: productId },
          });

          const productData = await productResponse.json();
          
          if (productData.data?.product) {
            productTitle = productData.data.product.title;
            productImage = productData.data.product.featuredImage?.url;
          }
        }
      } catch (error) {
        console.error("Error fetching product data:", error);
      }

      // Gerar token seguro
      const token = EmailService.generateSecureToken();

      // Criar convite de review
      const invitation = await db.reviewInvitation.create({
        data: {
          shop,
          orderId: order.id.toString(),
          customerId,
          customerEmail,
          customerName,
          productId,
          productTitle,
          productImage,
          scheduledFor: sendDate,
          token,
        },
      });

      console.log(`‚úÖ Convite autom√°tico criado para produto ${productTitle} (ID: ${invitation.id})`);
      convitesCriados++;
    }

    console.log(`üéâ Total de convites autom√°ticos criados: ${convitesCriados}`);

  } catch (error) {
    console.error("‚ùå Erro ao processar webhook orders/paid:", error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    return new Response(`Webhook error: ${errorMessage}`, { status: 500 });
  }

  return new Response();
}; 